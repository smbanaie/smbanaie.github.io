#!/usr/bin/env python
# -*- coding: utf-8 -*-
from handlers.index_handler import TornadoRequestBase
import uuid, os
import jdatetime,codecs
from user_area.smbanaie.smbanaie.userconf import *
from datetime import datetime
import tornado,pathlib
from utils.logger_setup import logger

class admin_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        # Get dashboard statistics
        stats = self.get_dashboard_stats()
        date = str(jdatetime.datetime.now())
        date = date.split('.')[0]

        self.render('admin/starter.html', stats=stats, date=date)

    def post(self, *args, **kwargs):
        action = self.get_argument('action', '')

        if action == 'recalculate_stats':
            return self.recalculate_stats()
        elif action == 'backup':
            return self.create_backup()
        elif action == 'generate_site':
            return self.generate_site()

        self.write("Invalid action")
        self.set_status(400)

    def get_dashboard_stats(self):
        """Calculate dashboard statistics."""
        stats = {
            'total_posts': 0,
            'total_categories': 0,
            'total_authors': 0,
            'recent_posts': [],
            'posts_by_category': {},
            'posts_by_month': {}
        }

        try:
            # Get categories from userconf
            from user_area.smbanaie.smbanaie.userconf import CATEGORIES, AUTHORS
            stats['total_categories'] = len(CATEGORIES.get('cat_list', []))
            stats['total_authors'] = len(AUTHORS)

            # Scan for posts
            base = pathlib.Path(USER_DIR) / 'content' / 'blog' / 'fa'
            if base.exists():
                posts = []
                for filepath in base.rglob('*.md'):
                    try:
                        meta = {}
                        with filepath.open('r', encoding='utf-8') as fh:
                            for line in fh:
                                line = line.strip()
                                if line == '':
                                    break
                                if ':' in line:
                                    k, v = line.split(':', 1)
                                    meta[k.strip().lower()] = v.strip()

                        post_info = {
                            'title': meta.get('title', filepath.stem),
                            'slug': filepath.stem,
                            'date': meta.get('date', ''),
                            'category': meta.get('category', ''),
                            'author': meta.get('authors', ''),
                            'path': str(filepath),
                            'mtime': filepath.stat().st_mtime
                        }
                        posts.append(post_info)

                        # Count by category
                        category = post_info['category']
                        if category:
                            stats['posts_by_category'][category] = stats['posts_by_category'].get(category, 0) + 1

                        # Count by month
                        if post_info['date']:
                            try:
                                date_obj = datetime.datetime.fromisoformat(post_info['date'])
                                month_key = f"{date_obj.year}-{date_obj.month:02d}"
                                stats['posts_by_month'][month_key] = stats['posts_by_month'].get(month_key, 0) + 1
                            except:
                                pass

                    except Exception as e:
                        # Skip files that can't be read or parsed
                        continue

                # Sort posts by date (most recent first)
                posts.sort(key=lambda x: x['mtime'], reverse=True)
                stats['recent_posts'] = posts[:5]  # Last 5 posts
                stats['total_posts'] = len(posts)

        except Exception as e:
            logger.error(f"Error calculating dashboard stats: {e}")

        return stats

    def recalculate_stats(self):
        """Recalculate all statistics and category counts."""
        try:
            # Recalculate article counts
            article_counts = self._get_article_counts()

            # Get current userconf data
            data = self._read_userconf_data()

            # Update the data with correct counts (this is mainly for verification)
            # The counts are calculated on-the-fly when pages load

            # Log the results
            logger.info(f"Statistics recalculated - Authors: {len(data['AUTHORS'])}, Categories: {len(data['CATEGORIES']['cat_list'])}, Articles: {sum(article_counts['authors'].values())}")

            # Return success response
            self.write("آمار با موفقیت بازسازی شد")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error recalculating stats: {e}")
            self.write(f"خطا در بازسازی آمار: {str(e)}")
            self.set_status(500)

    def create_backup(self):
        """Create a backup of the userconf and content."""
        try:
            import shutil
            import datetime

            # Create backup directory
            backup_dir = os.path.join(USER_DIR, 'backups')
            os.makedirs(backup_dir, exist_ok=True)

            # Create timestamp
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')

            # Backup userconf
            userconf_src = os.path.join(USER_DIR, 'userconf.py')
            userconf_dst = os.path.join(backup_dir, f'userconf_{timestamp}.py')
            shutil.copy2(userconf_src, userconf_dst)

            # Create content backup (optional - just log for now)
            logger.info(f"Backup created: {userconf_dst}")

            self.write("پشتیبان با موفقیت ایجاد شد")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error creating backup: {e}")
            self.write(f"خطا در ایجاد پشتیبان: {str(e)}")
            self.set_status(500)

    def generate_site(self):
        """Generate the Pelican site."""
        try:
            build_type = self.get_argument('build_type', 'build')

            # Import required modules
            import subprocess
            import os

            # Change to the user directory
            user_dir = USER_DIR

            # Determine the command based on build type
            if build_type == 'preview':
                command = ['invoke', 'preview']
            else:
                command = ['invoke', 'build']

            # Run the command
            logger.info(f"Running site generation command: {' '.join(command)} in {user_dir}")

            result = subprocess.run(
                command,
                cwd=user_dir,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )

            if result.returncode == 0:
                logger.info("Site generation completed successfully")
                self.write("سایت با موفقیت تولید شد")
                self.set_status(200)
            else:
                logger.error(f"Site generation failed: {result.stderr}")
                self.write(f"خطا در تولید سایت: {result.stderr}")
                self.set_status(500)

        except subprocess.TimeoutExpired:
            logger.error("Site generation timed out")
            self.write("خطا: تولید سایت زمان زیادی طول کشید")
            self.set_status(500)
        except Exception as e:
            logger.error(f"Error generating site: {e}")
            self.write(f"خطا در تولید سایت: {str(e)}")
            self.set_status(500)

class category_consistency_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Display category consistency report."""
        report_data = self.get_category_consistency_report()
        self.render('admin/category_consistency.html', **report_data)

    def post(self, *args, **kwargs):
        """Handle category reconciliation."""
        action = self.get_argument('action', '')

        if action == 'reconcile':
            return self.handle_reconciliation()
        else:
            self.write("Invalid action")
            self.set_status(400)

    def recalculate_stats(self):
        """Recalculate all statistics and category counts."""
        try:
            # Recalculate article counts
            article_counts = self._get_article_counts()

            # Get current userconf data
            data = self._read_userconf_data()

            # Update the data with correct counts (this is mainly for verification)
            # The counts are calculated on-the-fly when pages load

            # Log the results
            logger.info(f"Statistics recalculated - Authors: {len(data['AUTHORS'])}, Categories: {len(data['CATEGORIES']['cat_list'])}, Articles: {sum(article_counts['authors'].values())}")

            # Return success response
            self.write("آمار با موفقیت بازسازی شد")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error recalculating stats: {e}")
            self.write(f"خطا در بازسازی آمار: {str(e)}")
            self.set_status(500)

    def get_category_consistency_report(self):
        """Generate a report of category inconsistencies."""
        try:
            # Get categories from different sources
            file_categories = self._get_categories_from_files()
            folder_categories = self._get_categories_from_folders()
            userconf_categories = self._get_categories_from_userconf()

            # Analyze inconsistencies
            inconsistencies = self._analyze_category_inconsistencies(
                file_categories, folder_categories, userconf_categories
            )

            return {
                'error': '',
                'file_categories': file_categories,
                'folder_categories': folder_categories,
                'userconf_categories': userconf_categories,
                'inconsistencies': inconsistencies
            }

        except Exception as e:
            logger.error(f"Error generating category consistency report: {e}")
            return {
                'error': str(e),
                'file_categories': {},
                'folder_categories': [],
                'userconf_categories': [],
                'inconsistencies': []
            }

    def _get_categories_from_files(self):
        """Extract unique categories from article metadata."""
        import os
        import glob
        import re
        from user_area.smbanaie.smbanaie.userconf import CONTENT_DIR

        categories = {}

        # Find all markdown files
        blog_pattern = os.path.join(CONTENT_DIR, 'blog', '**', '*.md')
        blog_files = glob.glob(blog_pattern, recursive=True)

        for file_path in blog_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Extract category
                category_match = re.search(r'^category:\s*(.+)$', content, re.MULTILINE)
                if category_match:
                    category_name = category_match.group(1).strip()
                    if category_name not in categories:
                        categories[category_name] = []
                    categories[category_name].append(os.path.basename(file_path))

            except Exception as e:
                logger.error(f"Error reading file {file_path}: {e}")
                continue

        return categories

    def _get_categories_from_folders(self):
        """Get category folders from file system."""
        import os
        from user_area.smbanaie.smbanaie.userconf import CONTENT_DIR

        folders = []
        blog_path = os.path.join(CONTENT_DIR, 'blog', 'fa')

        if os.path.exists(blog_path):
            try:
                for item in os.listdir(blog_path):
                    item_path = os.path.join(blog_path, item)
                    if os.path.isdir(item_path):
                        folders.append(item)
            except Exception as e:
                logger.error(f"Error reading folders: {e}")

        return sorted(folders)

    def _get_categories_from_userconf(self):
        """Get categories from userconf."""
        from user_area.smbanaie.smbanaie.userconf import CATEGORIES

        userconf_cats = []
        for cat_id, cat_display in CATEGORIES.get('cat_list', []):
            userconf_cats.append({
                'id': cat_id,
                'display': cat_display
            })

        return userconf_cats

    def _analyze_category_inconsistencies(self, file_categories, folder_categories, userconf_categories):
        """Analyze inconsistencies between different category sources."""
        inconsistencies = []

        # Get all unique categories from different sources
        file_cat_names = set(file_categories.keys())
        folder_cat_names = set(folder_categories)
        userconf_cat_ids = {cat['id'] for cat in userconf_categories}
        userconf_cat_displays = {cat['display'] for cat in userconf_categories}

        # Find unmapped file categories
        persian_mappings = self._get_persian_mappings()
        mapped_categories = set()

        for file_cat in file_cat_names:
            if file_cat in userconf_cat_ids or file_cat in userconf_cat_displays:
                mapped_categories.add(file_cat)
            elif file_cat in persian_mappings:
                mapped_categories.add(file_cat)
            else:
                # Unmapped category
                inconsistencies.append({
                    'type': 'unmapped_file_category',
                    'category': file_cat,
                    'files_count': len(file_categories[file_cat]),
                    'sample_files': file_categories[file_cat][:3]
                })

        # Find folders without userconf categories
        for folder in folder_categories:
            if folder not in userconf_cat_ids and folder not in userconf_cat_displays:
                inconsistencies.append({
                    'type': 'folder_without_userconf',
                    'folder': folder,
                    'has_files': len([f for files in file_categories.values() for f in files if folder in f]) > 0
                })

        # Find userconf categories not used in files
        used_categories = mapped_categories
        for cat in userconf_categories:
            if cat['id'] not in used_categories and cat['display'] not in used_categories:
                # Check if this category has any Persian mappings used
                category_used = False
                for persian_cat, english_cat in persian_mappings.items():
                    if english_cat == cat['id'] and persian_cat in file_cat_names:
                        category_used = True
                        break

                if not category_used:
                    inconsistencies.append({
                        'type': 'unused_userconf_category',
                        'category_id': cat['id'],
                        'category_display': cat['display']
                    })

        return inconsistencies

    def _get_persian_mappings(self):
        """Get the Persian category mappings."""
        return {
            'فرهنگ و جامعه': 'Culture',
            'روزنوشت': 'Diary',
            'تخصص': 'Tech',
            'تکنولوژی': 'Tech',
            'تخصصی': 'Tech',
            'فناوری': 'Tech',
            'بر بلندای شعر و عرفان': 'Self-Contemplation',
            'پرواز اندیشه': 'Self-Contemplation',
            'خواندنیها': 'Misc',
            'گوناگون': 'Misc',
            'متفرقه': 'Misc',
            'روحانیات': 'Meditation',
            'مراقبه': 'Meditation',
            'آرامش ذهنی و مراقبه': 'Meditation'
        }

    def handle_reconciliation(self):
        """Handle category reconciliation requests."""
        try:
            reconciliation_type = self.get_argument('reconciliation_type', '')
            base_category = self.get_argument('base_category', '')
            target_categories = self.get_arguments('target_categories[]')

            if reconciliation_type == 'add_mapping':
                # Add new Persian mappings
                return self._add_category_mappings(base_category, target_categories)
            elif reconciliation_type == 'update_file_categories':
                # Update categories in files
                return self._update_file_categories(target_categories, base_category)
            elif reconciliation_type == 'add_userconf_category':
                # Add category to userconf
                return self._add_userconf_category(base_category)
            else:
                self.write("نوع عملیات نامعتبر")
                self.set_status(400)

        except Exception as e:
            logger.error(f"Error in reconciliation: {e}")
            self.write(f"خطا در عملیات: {str(e)}")
            self.set_status(500)

    def _add_category_mappings(self, base_category, target_categories):
        """Add new Persian category mappings."""
        try:
            # This would modify the _get_persian_mappings method or add to a config file
            # For now, we'll just return success and suggest manual update
            logger.info(f"Would add mappings: {target_categories} -> {base_category}")

            self.write("نقشه‌برداری با موفقیت اضافه شد. لطفاً کد را به‌روزرسانی کنید.")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error adding mappings: {e}")
            self.write(f"خطا در اضافه کردن نقشه‌برداری: {str(e)}")
            self.set_status(500)

    def _update_file_categories(self, file_categories, new_category):
        """Update category metadata in files."""
        try:
            import os
            import glob
            import re
            from user_area.smbanaie.smbanaie.userconf import CONTENT_DIR

            updated_count = 0

            # Find all markdown files
            blog_pattern = os.path.join(CONTENT_DIR, 'blog', '**', '*.md')
            blog_files = glob.glob(blog_pattern, recursive=True)

            for file_path in blog_files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                    # Check if file has one of the target categories
                    category_match = re.search(r'^category:\s*(.+)$', content, re.MULTILINE)
                    if category_match:
                        current_category = category_match.group(1).strip()
                        if current_category in file_categories:
                            # Update the category
                            new_content = re.sub(
                                r'^category:\s*(.+)$',
                                f'category: {new_category}',
                                content,
                                flags=re.MULTILINE
                            )

                            # Write back the file
                            with open(file_path, 'w', encoding='utf-8') as f:
                                f.write(new_content)

                            updated_count += 1
                            logger.info(f"Updated category in {os.path.basename(file_path)}: {current_category} -> {new_category}")

                except Exception as e:
                    logger.error(f"Error updating file {file_path}: {e}")
                    continue

            self.write(f"{updated_count} فایل با موفقیت به‌روزرسانی شد")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error updating file categories: {e}")
            self.write(f"خطا در به‌روزرسانی دسته‌بندی فایل‌ها: {str(e)}")
            self.set_status(500)

    def _add_userconf_category(self, category_name):
        """Add a new category to userconf."""
        try:
            # This would require modifying the userconf.py file
            # For safety, we'll suggest manual addition
            logger.info(f"Would add category to userconf: {category_name}")

            self.write("دسته‌بندی باید به صورت دستی به userconf.py اضافه شود")
            self.set_status(200)

        except Exception as e:
            logger.error(f"Error adding userconf category: {e}")
            self.write(f"خطا در اضافه کردن دسته‌بندی: {str(e)}")
            self.set_status(500)


class add_new_post_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        catList = {}
        authors = []
        for clist in CATEGORIES["cat_list"] :
            catList [clist[0]] = clist[1]
        for user in AUTHORS :
            authors.append(user)
        date = str(jdatetime.datetime.now())
        fa_date_components = date[:10].split("-")
        month = fa_date_components[1]
        if  month[0]=="0":
            month = month[1]
        self.render('admin/posts/add.html',catlist = catList,authors=authors,year=fa_date_components[0] ,month= month )

    def post(self, *args, **kwargs):
        date = str(jdatetime.datetime.now())
        fa_date_components =date[:10].split("-")
        d = datetime.now()
        en_date_components ="%d-%d-%d"%(d.year,d.month,d.day)
        # ftest = open(r"F:\My GitHub Repos\WebSiteMaker\t.txt","a")
        # ftest.write(self.get("tags"))
        # ftest.close()
        try:
            logger.debug("Received new post request: title=%s slug=%s", self.get_argument('title'), self.get_argument('slug'))
        except Exception:
            logger.debug("Received new post request (could not read title/slug yet)")

        article_path = USER_DIR +os.path.sep+"content"+os.path.sep+"blog"+os.path.sep+"fa"
        article_path+=os.path.sep+self.get_argument("category")+os.path.sep
        article_path+= fa_date_components[0]+os.path.sep
        if  fa_date_components[1][0]=="0":
            article_path += fa_date_components[1][1]
        else :
            article_path += fa_date_components[1]
        self.write("\n"+article_path)
        pathlib.Path(article_path).mkdir(parents=True, exist_ok=True)
        self.write("\n"+article_path+os.path.sep+self.get_argument("slug")+".md")
        f= codecs.open(article_path+os.path.sep+self.get_argument("slug")+".md", "w",encoding="utf-8")
        f.write("title:"+ self.get_argument('title')+ "\r\n")
        self.write("\n"+"title:"+ self.get_argument('title')+ "\r\n")
        f.write("date:"+ en_date_components + "\r\n")
        self.write("\n"+"date:"+ en_date_components + "\r\n")
        f.write("modified:"+ en_date_components + "\r\n")
        self.write("\n"+"modified:"+ en_date_components + "\r\n")
        f.write("icon:icon-link2\r\n")
        self.write("\n"+"icon:icon-link2\r\n")
        f.write("lang:fa\r\n")
        self.write("\n"+"lang:fa\r\n")
        f.write("category:"+self.get_argument('cat_name')+ "\r\n")
        self.write("\n"+"category:"+self.get_argument('cat_name')+ "\r\n")
        f.write("tags:"+self.get_argument('tagsvalues')+ "\r\n")
        self.write("\n"+"tags:"+self.get_argument('tagsvalues')+ "\r\n")
        f.write("Slug:"+self.get_argument('slug')+ "\r\n")
        self.write("\n"+"Slug:"+self.get_argument('slug')+ "\r\n")
        f.write("authors:"+self.get_argument('authors')+ "\r\n")
        self.write("\n"+"authors:"+self.get_argument('authors')+ "\r\n")
        f.write("summary:"+self.get_argument('summary')+ "\r\n")
        self.write("\n"+"summary:"+self.get_argument('summary')+ "\r\n")
        f.write("image: "+self.get_argument("img_adr")+self.get_argument("image")+ "\r\n\r\n")
        self.write("\n"+"image: "+self.get_argument("img_adr")+self.get_argument("image")+ "\r\n\r\n")
        f.write("!["+self.get_argument("img_desc")+" <>](/images"+self.get_argument("img_adr")+self.get_argument("image")+")\r\n\r\n")
        self.write("\n"+"!["+self.get_argument("img_desc")+" <>](/images"+self.get_argument("img_adr")+self.get_argument("image")+")\r\n\r\n")
        f.write(self.get_argument('article'))
        self.write("\n"+self.get_argument('article'))
        f.close()
        logger.info("Wrote new post: %s", article_path+os.path.sep+self.get_argument("slug")+".md")
        try:
            self.finish("\n"+article_path)
        except Exception:
            # If Tornado has trouble finishing (e.g. connection closed), still log
            logger.debug("Finished response for post creation (connection may be closed)")
        return
        self.write("\n"+"summary:"+self.get_argument('summary')+ "\r\n")
        f.write("image: "+self.get_argument("img_adr")+self.get_argument("image")+ "\r\n\r\n")
        self.write("\n"+"image: "+self.get_argument("img_adr")+self.get_argument("image")+ "\r\n\r\n")
        f.write("!["+self.get_argument("img_desc")+" <>](/images"+self.get_argument("img_adr")+self.get_argument("image")+")\r\n\r\n")
        self.write("\n"+"!["+self.get_argument("img_desc")+" <>](/images"+self.get_argument("img_adr")+self.get_argument("image")+")\r\n\r\n")
        f.write(self.get_argument('article'))
        self.write("\n"+self.get_argument('article'))
        f.close()
        logger.info("Wrote new post: %s", article_path+os.path.sep+self.get_argument("slug")+".md")
        try:
            self.finish("\n"+article_path)
        except Exception:
            # If Tornado has trouble finishing (e.g. connection closed), still log
            logger.debug("Finished response for post creation (connection may be closed)")
        return


class posts_list_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Scan USER_DIR/content/blog/fa for Markdown posts and render a paginated list.

        Query params:
        - page: 1-based page number (default 1)
        - page_size: items per page (default 20)
        """
        try:
            base = pathlib.Path(USER_DIR) / 'content' / 'blog' / 'fa'
        except Exception:
            base = pathlib.Path('')

        posts = []
        if base.exists():
            for filepath in base.rglob('*.md'):
                try:
                    meta = {}
                    with filepath.open('r', encoding='utf-8') as fh:
                        for line in fh:
                            line = line.strip()
                            if line == '':
                                break
                            if ':' in line:
                                k, v = line.split(':', 1)
                                meta[k.strip().lower()] = v.strip()
                    mtime = filepath.stat().st_mtime
                    slug = filepath.stem
                    from urllib.parse import quote_plus
                    posts.append({
                        'title': meta.get('title', slug),
                        'slug': slug,
                        'date': meta.get('date', ''),
                        'category': meta.get('category', ''),
                        'path': str(filepath),
                        'edit_url': '/admin/posts/edit?file=' + quote_plus(str(filepath)),
                        'mtime': mtime,
                    })
                except Exception as e:
                    logger.debug('Skipping file %s due to parse error: %s', filepath, e)

        # sort by mtime desc
        posts.sort(key=lambda p: p['mtime'], reverse=True)

        # Pagination
        try:
            page = int(self.get_argument('page', '1'))
        except Exception:
            page = 1
        try:
            page_size = int(self.get_argument('page_size', '20'))
        except Exception:
            page_size = 20
        if page < 1:
            page = 1
        if page_size < 1:
            page_size = 20

        total = len(posts)
        total_pages = (total + page_size - 1) // page_size if total else 1
        if page > total_pages:
            page = total_pages

        start = (page - 1) * page_size
        end = start + page_size
        page_items = posts[start:end]

        pages = list(range(1, total_pages + 1))

        self.render('admin/posts/list.html', posts=page_items, page=page, page_size=page_size,
                    total=total, total_pages=total_pages, pages=pages)


class categories_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Display category management interface."""
        # Get current categories from userconf
        from user_area.smbanaie.smbanaie.userconf import CATEGORIES

        # Get article counts
        article_counts = self._get_article_counts()

        # Prepare category data (keep original tuple format for backward compatibility)
        categories_data = []
        for cat_id, cat_name in CATEGORIES.get('cat_list', []):
            categories_data.append((cat_id, cat_name))

        self.render('admin/categories/index.html',
                   categories=categories_data,
                   category_counts=article_counts['categories'],
                   category_status=CATEGORIES.get('status', {}),
                   default_category=CATEGORIES.get('default_category', ''))

    def post(self, *args, **kwargs):
        """Handle category creation, editing, or deletion."""
        action = self.get_argument('action', '')
        logger.info(f"Categories POST action: {action}")

        success = False
        if action == 'add':
            logger.info("Calling add_category")
            success = self.add_category()
        elif action == 'edit':
            success = self.edit_category()
        elif action == 'delete':
            success = self.delete_category()

        if success:
            self.redirect('/admin/categories')

    def _is_english_name(self, name):
        """Check if name contains only English characters, numbers, and underscores."""
        import re
        return bool(re.match(r'^[a-zA-Z0-9_]+$', name))

    def add_category(self):
        """Add a new category."""
        name = self.get_argument('name', '').strip()
        display_name = self.get_argument('display_name', '').strip()
        status = self.get_argument('status', 'active')
        is_default = self.get_argument('is_default', '0') == '1'
        logger.info(f"Adding category: name='{name}', display_name='{display_name}', status='{status}', default={is_default}")

        if not name or not display_name:
            logger.warning("Category name or display name missing")
            self.set_status(400)
            self.write('Error: Name and display name are required')
            return

        # Validate that technical name is in English
        if not self._is_english_name(name):
            logger.warning(f"Category name contains non-English characters: '{name}'")
            self.set_status(400)
            self.write('Error: نام فنی دسته‌بندی باید فقط شامل حروف انگلیسی، اعداد و زیرخط (_) باشد')
            return

        try:
            # Read current data
            data = self._read_userconf_data()

            # Check if category already exists (by name)
            existing_names = [cat[0] for cat in data['CATEGORIES']['cat_list']]
            if name in existing_names:
                self.set_status(400)
                self.write(f'Error: Category "{name}" already exists')
                return

            # Add new category to the cat_list
            data['CATEGORIES']['cat_list'].append((name, display_name))

            # Set category status
            data['CATEGORIES']['status'][name] = status

            # Handle default category
            if is_default:
                # Ensure the default category is active
                if status == 'active':
                    data['CATEGORIES']['default_category'] = name
                else:
                    self.set_status(400)
                    self.write('Error: Cannot set an inactive category as default')
                    return
            elif data['CATEGORIES'].get('default_category', '') == '' and len(data['CATEGORIES']['cat_list']) == 1:
                # If this is the first category, make it default
                data['CATEGORIES']['default_category'] = name

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Added new category: {name} ({display_name}, status: {status}, default: {is_default})")
            return True

        except Exception as e:
            logger.error(f"Error adding category {name}: {e}")
            self.set_status(500)
            self.write(f'Error adding category: {str(e)}')

    def edit_category(self):
        """Edit an existing category."""
        old_name = self.get_argument('old_name', '')
        new_name = self.get_argument('new_name', '').strip()
        new_display_name = self.get_argument('new_display_name', '').strip()
        status = self.get_argument('status', 'active')
        is_default = self.get_argument('is_default', '0') == '1'

        if not old_name or not new_name or not new_display_name:
            self.set_status(400)
            self.write('Error: All fields are required')
            return

        # Validate that technical name is in English
        if not self._is_english_name(new_name):
            logger.warning(f"Category name contains non-English characters: '{new_name}'")
            self.set_status(400)
            self.write('Error: نام فنی دسته‌بندی باید فقط شامل حروف انگلیسی، اعداد و زیرخط (_) باشد')
            return

        try:
            # Read current data
            data = self._read_userconf_data()

            # Find the category by old_name
            cat_list = data['CATEGORIES']['cat_list']
            category_index = None
            for i, (name, display) in enumerate(cat_list):
                if name == old_name:
                    category_index = i
                    break

            if category_index is None:
                self.set_status(404)
                self.write(f'Error: Category "{old_name}" not found')
                return

            # Check if new name already exists (and it's not the same category)
            existing_names = [cat[0] for cat in cat_list]
            if new_name in existing_names and new_name != old_name:
                self.set_status(400)
                self.write(f'Error: Category "{new_name}" already exists')
                return

            # Update the category
            cat_list[category_index] = (new_name, new_display_name)

            # Update status
            if old_name in data['CATEGORIES']['status']:
                del data['CATEGORIES']['status'][old_name]
            data['CATEGORIES']['status'][new_name] = status

            # Handle default category
            if is_default:
                # Ensure the default category is active
                if status == 'active':
                    data['CATEGORIES']['default_category'] = new_name
                else:
                    self.set_status(400)
                    self.write('Error: Cannot set an inactive category as default')
                    return
            elif data['CATEGORIES']['default_category'] == old_name:
                # If we were the default, and we're not setting a new default, clear it
                data['CATEGORIES']['default_category'] = ''

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Updated category: {old_name} -> {new_name} (status: {status}, default: {is_default})")
            return True

        except Exception as e:
            logger.error(f"Error editing category {old_name}: {e}")
            self.set_status(500)
            self.write(f'Error editing category: {str(e)}')

    def delete_category(self):
        """Delete a category with migration options."""
        name = self.get_argument('name', '')
        migration_option = self.get_argument('migration_option', 'keep')  # keep, replace, default
        replacement_category = self.get_argument('replacement_category', '')

        if not name:
            self.set_status(400)
            self.write('Error: Category name is required')
            return

        try:
            # Read current data
            data = self._read_userconf_data()

            # Find the category to delete
            cat_list = data['CATEGORIES']['cat_list']
            category_to_delete = None
            for cat_id, cat_name in cat_list:
                if cat_id == name:
                    category_to_delete = (cat_id, cat_name)
                    break

            if not category_to_delete:
                self.set_status(404)
                self.write(f'Error: Category "{name}" not found')
                return

            # Prevent deletion of default category
            if name == data['CATEGORIES'].get('default_category'):
                # Check if there are other active categories available
                other_categories = [(cat_id, cat_name) for cat_id, cat_name in cat_list if cat_id != name and data['CATEGORIES']['status'].get(cat_id, 'active') == 'active']
                if other_categories:
                    self.set_status(400)
                    self.write(f'خطا: نمی‌توان دسته‌بندی پیش‌فرض "{category_to_delete[1]}" را حذف کرد. لطفاً ابتدا یک دسته‌بندی فعال دیگر را به عنوان پیش‌فرض تنظیم کنید، سپس اقدام به حذف کنید.')
                else:
                    self.set_status(400)
                    self.write(f'خطا: نمی‌توان دسته‌بندی پیش‌فرض "{category_to_delete[1]}" را حذف کرد. این تنها دسته‌بندی فعال است. لطفاً ابتدا یک دسته‌بندی فعال دیگر اضافه کرده و آن را به عنوان پیش‌فرض تنظیم کنید.')
                return

            # Handle migration of existing articles (only if migration_option is provided and category has articles)
            article_counts = self._get_article_counts()
            category_article_count = article_counts['categories'].get(name, 0)

            if category_article_count > 0:
                if migration_option == 'replace' and replacement_category:
                    # Replace category in all articles
                    self._migrate_category_in_articles(category_to_delete[1], replacement_category)
                elif migration_option == 'default':
                    # Replace with default category
                    default_cat_name = None
                    for cat_id, cat_name in cat_list:
                        if cat_id == data['CATEGORIES'].get('default_category', ''):
                            default_cat_name = cat_name
                            break
                    if default_cat_name and default_cat_name != category_to_delete[1]:
                        self._migrate_category_in_articles(category_to_delete[1], default_cat_name)

            # Remove the category from the list
            data['CATEGORIES']['cat_list'] = [(cat_id, cat_name) for cat_id, cat_name in cat_list if cat_id != name]

            # Remove from status dict
            if 'status' in data['CATEGORIES'] and name in data['CATEGORIES']['status']:
                del data['CATEGORIES']['status'][name]

            # If this was the default category, set a new default
            if data['CATEGORIES'].get('default_category') == name:
                if data['CATEGORIES']['cat_list']:
                    data['CATEGORIES']['default_category'] = data['CATEGORIES']['cat_list'][0][0]
                else:
                    data['CATEGORIES']['default_category'] = ''

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Deleted category: {name} (migration: {migration_option}, articles: {category_article_count})")
            return True

        except Exception as e:
            logger.error(f"Error deleting category {name}: {e}")
            self.set_status(500)
            self.write(f'Error deleting category: {str(e)}')

    def _migrate_category_in_articles(self, old_category_name, new_category_name):
        """Migrate articles from old category to new category."""
        import os
        import glob
        import re

        from user_area.smbanaie.smbanaie.userconf import CONTENT_DIR

        # Find all markdown files
        blog_pattern = os.path.join(CONTENT_DIR, 'blog', '**', '*.md')
        blog_files = glob.glob(blog_pattern, recursive=True)

        for file_path in blog_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Check if file contains the old category
                category_match = re.search(r'^category:\s*(.+)$', content, re.MULTILINE)
                if category_match and category_match.group(1).strip() == old_category_name:
                    # Replace the category
                    new_content = re.sub(
                        r'^category:\s*(.+)$',
                        f'category: {new_category_name}',
                        content,
                        flags=re.MULTILINE
                    )

                    # Write back the file
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(new_content)

            except Exception as e:
                # Skip files that can't be processed
                continue


class users_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Display user management interface (version 2)."""
        try:
            # Get user data from userconf
            from user_area.smbanaie.smbanaie.userconf import AUTHORS, AUTHOR_STATUS, DEFAULT_AUTHOR

            # Get article counts for each user
            user_counts = {}
            for author in AUTHORS:
                user_counts[author] = self._count_articles_by_author(author)

            # Get user status data
            user_status = AUTHOR_STATUS

            # Get default author
            default_author = DEFAULT_AUTHOR

            # Prepare user data for template
            users_data = []
            for author in AUTHORS:
                users_data.append(author)  # Keep original format for backward compatibility

            self.render('admin/users/index.html',
                       users=users_data,
                       user_status=user_status,
                       user_counts=user_counts,
                       default_author=default_author)

        except Exception as e:
            logger.error(f"Error loading users page: {e}")
            self.set_status(500)
            self.write(f"خطا در بارگذاری صفحه کاربران: {str(e)}")

    def post(self, *args, **kwargs):
        """Handle user management actions."""
        action = self.get_argument('action', '')

        if action == 'add':
            self.add_user()
        elif action == 'edit':
            self.edit_user()
        elif action == 'delete':
            self.delete_user()
        else:
            self.write("Invalid action")

    def _count_articles_by_author(self, author_name):
        """Count articles by a specific author."""
        try:
            import os
            from pathlib import Path
            from user_area.smbanaie.smbanaie.userconf import USER_DIR

            content_dir = Path(USER_DIR) / "content" / "blog" / "fa"
            count = 0

            if content_dir.exists():
                for category_dir in content_dir.iterdir():
                    if category_dir.is_dir():
                        for year_dir in category_dir.iterdir():
                            if year_dir.is_dir() and year_dir.name.isdigit():
                                for month_dir in year_dir.iterdir():
                                    if month_dir.is_dir() and month_dir.name.isdigit():
                                        for md_file in month_dir.glob("*.md"):
                                            try:
                                                with open(md_file, 'r', encoding='utf-8') as f:
                                                    content = f.read()
                                                    # Check if author is in the front matter
                                                    author_patterns = [
                                                        f"authors: {author_name}",
                                                        f"Authors: {author_name}",
                                                        f"Author: {author_name}",
                                                        f"author: {author_name}"
                                                    ]
                                                    for pattern in author_patterns:
                                                        if pattern in content:
                                                            count += 1
                                                            break
                                            except Exception as e:
                                                logger.error(f"Error reading file {md_file}: {e}")

            return count

        except Exception as e:
            logger.error(f"Error counting articles for author {author_name}: {e}")
            return 0

    def _read_userconf_data(self):
        """Read current userconf data."""
        try:
            from user_area.smbanaie.smbanaie.userconf import AUTHORS, AUTHOR_STATUS, DEFAULT_AUTHOR, CATEGORIES

            return {
                'AUTHORS': list(AUTHORS),  # Convert to list to make it mutable
                'AUTHOR_STATUS': dict(AUTHOR_STATUS),  # Convert to dict to make it mutable
                'DEFAULT_AUTHOR': DEFAULT_AUTHOR,
                'CATEGORIES': dict(CATEGORIES)  # Include categories for completeness
            }
        except Exception as e:
            logger.error(f"Error reading userconf data: {e}")
            raise

    def _write_userconf_data(self, data):
        """Write updated userconf data back to file."""
        try:
            import os
            from user_area.smbanaie.smbanaie.userconf import USER_DIR

            userconf_path = os.path.join(USER_DIR, 'userconf.py')

            # Read the current file content
            with open(userconf_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Update the data structures
            # AUTHORS
            authors_start = content.find('AUTHORS = [')
            if authors_start != -1:
                authors_end = content.find(']', authors_start) + 1
                authors_str = 'AUTHORS = ' + str(data['AUTHORS'])
                content = content[:authors_start] + authors_str + content[authors_end:]

            # AUTHOR_STATUS
            status_start = content.find('AUTHOR_STATUS = {')
            if status_start != -1:
                status_end = content.find('}', status_start) + 1
                status_str = 'AUTHOR_STATUS = ' + str(data['AUTHOR_STATUS'])
                content = content[:status_start] + status_str + content[status_end:]

            # DEFAULT_AUTHOR
            default_start = content.find('DEFAULT_AUTHOR = "')
            if default_start != -1:
                default_end = content.find('"', default_start + len('DEFAULT_AUTHOR = "')) + 1
                default_str = f'DEFAULT_AUTHOR = "{data["DEFAULT_AUTHOR"]}"'
                content = content[:default_start] + default_str + content[default_end:]

            # Write back to file
            with open(userconf_path, 'w', encoding='utf-8') as f:
                f.write(content)

            logger.info(f"Updated userconf.py with new data")

        except Exception as e:
            logger.error(f"Error writing userconf data: {e}")
            raise

    def add_user(self):
        """Add a new user."""
        try:
            username = self.get_argument('username', '').strip()

            if not username:
                self.write("نام کاربری نمی‌تواند خالی باشد")
                return

            # Get current userconf data
            data = self._read_userconf_data()

            # Check if user already exists
            if username in data['AUTHORS']:
                self.write("این نام کاربری از قبل وجود دارد")
                return

            # Add user to authors list
            data['AUTHORS'].append(username)

            # Add user to status dict with active status
            data['AUTHOR_STATUS'][username] = 'active'

            # If this is the first user, set as default
            if not data['DEFAULT_AUTHOR']:
                data['DEFAULT_AUTHOR'] = username

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Added new user: {username}")
            self.redirect('/admin/users')

        except Exception as e:
            logger.error(f"Error adding user {username}: {e}")
            self.set_status(500)
            self.write(f'Error adding user: {str(e)}')

    def edit_user(self):
        """Edit an existing user."""
        try:
            old_username = self.get_argument('old_username', '').strip()
            new_username = self.get_argument('new_username', '').strip()
            status = self.get_argument('status', 'active')
            is_default = self.get_argument('is_default', '0') == '1'

            if not old_username or not new_username:
                self.write("نام کاربری نمی‌تواند خالی باشد")
                return

            # Get current userconf data
            data = self._read_userconf_data()

            # Check if old user exists
            if old_username not in data['AUTHORS']:
                self.write("کاربر مورد نظر یافت نشد")
                return

            # Check if new username already exists (if different from old)
            if new_username != old_username and new_username in data['AUTHORS']:
                self.write("این نام کاربری از قبل وجود دارد")
                return

            # Update username if changed
            if new_username != old_username:
                # Update in authors list
                idx = data['AUTHORS'].index(old_username)
                data['AUTHORS'][idx] = new_username

                # Update in status dict
                if old_username in data['AUTHOR_STATUS']:
                    data['AUTHOR_STATUS'][new_username] = data['AUTHOR_STATUS'].pop(old_username)

                # Update default author if needed
                if data['DEFAULT_AUTHOR'] == old_username:
                    data['DEFAULT_AUTHOR'] = new_username

                username = new_username
            else:
                username = old_username

            # Update status
            data['AUTHOR_STATUS'][username] = status

            # Update default author
            if is_default:
                data['DEFAULT_AUTHOR'] = username
            elif data['DEFAULT_AUTHOR'] == username and not is_default:
                # If we're removing default status, we need another default
                # Find another active user to be default
                for author in data['AUTHORS']:
                    if author != username and data['AUTHOR_STATUS'].get(author, 'active') == 'active':
                        data['DEFAULT_AUTHOR'] = author
                        break

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Updated user: {old_username} -> {username}")
            self.redirect('/admin/users')

        except Exception as e:
            logger.error(f"Error editing user {old_username}: {e}")
            self.set_status(500)
            self.write(f'Error editing user: {str(e)}')

    def delete_user(self):
        """Delete a user."""
        try:
            username = self.get_argument('username', '').strip()

            if not username:
                self.write("نام کاربری نمی‌تواند خالی باشد")
                return

            # Get current userconf data
            data = self._read_userconf_data()

            # Check if user exists
            if username not in data['AUTHORS']:
                self.write("کاربر مورد نظر یافت نشد")
                return

            # Check if this is the default author
            if data['DEFAULT_AUTHOR'] == username:
                # Find another active user to be the new default
                new_default = None
                for author in data['AUTHORS']:
                    if author != username and data['AUTHOR_STATUS'].get(author, 'active') == 'active':
                        new_default = author
                        break

                if new_default:
                    data['DEFAULT_AUTHOR'] = new_default
                else:
                    self.write(f'Error: Cannot delete default author "{username}". Please set another active author as default first, then try deleting.')
                    return

            # Check if this is the last active user
            active_users = [author for author in data['AUTHORS'] if data['AUTHOR_STATUS'].get(author, 'active') == 'active']
            if len(active_users) == 1 and active_users[0] == username:
                self.write(f'Error: Cannot delete default author "{username}". This is the only active author. Please add another active author and set it as default before deleting.')
                return

            # Remove the user
            data['AUTHORS'].remove(username)

            # Remove from status dict
            if username in data['AUTHOR_STATUS']:
                del data['AUTHOR_STATUS'][username]

            # If we had no default author and this was the last user, set a new default
            if not data['DEFAULT_AUTHOR'] and data['AUTHORS']:
                data['DEFAULT_AUTHOR'] = data['AUTHORS'][0]

            # Write back the updated data to file
            self._write_userconf_data(data)

            logger.info(f"Deleted user: {username}")
            self.redirect('/admin/users')

        except Exception as e:
            logger.error(f"Error deleting user {username}: {e}")
            self.set_status(500)
            self.write(f'Error deleting user: {str(e)}')



class settings_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Display settings management interface."""
        # Get current settings from userconf
        from user_area.smbanaie.smbanaie.userconf import USER_DIR, CONTENT_DIR, AUTHORS, CATEGORIES, SITE_REPO, DEFAULT_IMAGE_PATH
        
        settings = {
            'user_dir': USER_DIR,
            'content_dir': CONTENT_DIR,
            'authors': AUTHORS,
            'categories': CATEGORIES.get('cat_list', []),
            'site_repo': SITE_REPO,
            'default_image_path': DEFAULT_IMAGE_PATH
        }
        
        self.render('admin/settings/index.html', settings=settings)

    def post(self, *args, **kwargs):
        """Handle settings updates."""
        action = self.get_argument('action', '')
        
        if action == 'update_site':
            self.update_site_settings()
        elif action == 'update_paths':
            self.update_path_settings()
        
        self.redirect('/admin/settings')

    def update_site_settings(self):
        """Update site-related settings."""
        site_repo = self.get_argument('site_repo', '').strip()
        
        # Read current userconf
        userconf_path = USER_DIR + os.path.sep + 'userconf.py'
        with open(userconf_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Update SITE_REPO
        import re
        pattern = r'SITE_REPO\s*=\s*"[^"]*"'
        replacement = f'SITE_REPO = "{site_repo}"'
        updated_content = re.sub(pattern, replacement, content)
        
        # Write back to file
        with open(userconf_path, 'w', encoding='utf-8') as f:
            f.write(updated_content)
        
        logger.info(f"Updated site repo: {site_repo}")

    def update_path_settings(self):
        """Update path-related settings."""
        user_dir = self.get_argument('user_dir', '').strip()
        default_image_path = self.get_argument('default_image_path', '').strip()
        
        # Read current userconf
        userconf_path = USER_DIR + os.path.sep + 'userconf.py'
        with open(userconf_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Update paths
        import re
        content = re.sub(r'USER_DIR\s*=\s*r"[^"]*"', f'USER_DIR = r"{user_dir}"', content)
        content = re.sub(r'DEFAULT_IMAGE_PATH\s*=\s*str\(Path\([^)]*\)', 
                        f'DEFAULT_IMAGE_PATH = str(Path("{default_image_path}"))', content)
        
        # Write back to file
        with open(userconf_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Updated paths: USER_DIR={user_dir}, DEFAULT_IMAGE_PATH={default_image_path}")


class edit_post_Handler(TornadoRequestBase):
    def get(self, *args, **kwargs):
        """Load a markdown file and render the add/edit form prefilled."""
        from urllib.parse import unquote_plus
        file_param = self.get_argument('file', None)
        if not file_param:
            self.write('Missing file parameter')
            return
        filepath = pathlib.Path(unquote_plus(file_param))
        if not filepath.exists():
            self.write('File not found: %s' % filepath)
            return

        meta = {}
        body_lines = []
        with filepath.open('r', encoding='utf-8') as fh:
            in_meta = True
            for line in fh:
                if in_meta:
                    stripped = line.strip()
                    if stripped == '':
                        in_meta = False
                        continue
                    if ':' in stripped:
                        k, v = stripped.split(':', 1)
                        meta[k.strip().lower()] = v.strip()
                else:
                    body_lines.append(line)

        article_body = ''.join(body_lines).lstrip('\n')
        # Replace {static} placeholder with empty string since path already contains /images
        article_body = article_body.replace('{static}', '')

        # prepare catlist and authors similar to add_new_post_Handler.get
        catList = {}
        authors = []
        for clist in CATEGORIES["cat_list"] :
            catList [clist[0]] = clist[1]
        for user in AUTHORS :
            authors.append(user)

        # determine year/month for form
        date = meta.get('date', str(jdatetime.datetime.now()))
        fa_date_components = date[:10].split("-")
        month = fa_date_components[1] if len(fa_date_components) > 1 else ''
        if month and month[0] == '0':
            month = month[1]

# render the modern add form with prefilled values
        self.render('admin/posts/add.html',
                    catlist=catList,
                    authors=authors,
                    year=fa_date_components[0] if fa_date_components else '',
                    month=month,
                    title=meta.get('title', ''),
                    slug=filepath.stem,
                    tagsvalues=meta.get('tags', ''),
                    summary=meta.get('summary', ''),
                    img_adr=meta.get('image', '').split(')')[-1] if meta.get('image') else '',
                    image=meta.get('image', '').split('/')[-1] if meta.get('image') else '',
                    img_desc=meta.get('img_desc', ''),
                    category_value=meta.get('category', ''),
                    authors_value=meta.get('authors', ''),
                    article=article_body,
                    edit_mode=True,
                    file_path=str(filepath)
                    )

    def post(self, *args, **kwargs):
        """Handle post edit form submission."""
        action = self.get_argument('action', '')
        file_path = self.get_argument('file_path', '')
        
        if action == 'edit' and file_path:
            self.edit_existing_post(file_path)
        else:
            self.write('Invalid request')
            return

    def edit_existing_post(self, file_path):
        """Edit an existing post file."""
        filepath = pathlib.Path(file_path)
        if not filepath.exists():
            self.set_status(400)
            self.write('File not found')
            return

        # Get form data
        title = self.get_argument('title', '').strip()
        slug = self.get_argument('slug', '').strip()
        category = self.get_argument('category', '').strip()
        authors = self.get_argument('authors', '').strip()
        tags = self.get_argument('tags', '').strip()
        summary = self.get_argument('summary', '').strip()
        article = self.get_argument('article', '').strip()
        img_adr = self.get_argument('img_adr', '').strip()
        image = self.get_argument('image', '').strip()
        img_desc = self.get_argument('img_desc', '').strip()
        
        if not title or not slug or not category or not authors:
            self.set_status(400)
            self.write('Required fields are missing')
            return

        # Parse date from filename or use current date
        try:
            fa_date_components = str(jdatetime.datetime.now())[:10].split("-")
            d = datetime.now()
            en_date_components = "%d-%d-%d" % (d.year, d.month, d.day)
        except Exception:
            en_date_components = str(datetime.now())[:10]

        # Write updated content
        with filepath.open('w', encoding='utf-8') as f:
            f.write("title: " + title + "\r\n")
            f.write("date: " + en_date_components + "\r\n")
            f.write("modified: " + en_date_components + "\r\n")
            f.write("icon: icon-link2\r\n")
            f.write("lang: fa\r\n")
            f.write("category: " + category + "\r\n")
            f.write("tags: " + tags + "\r\n")
            f.write("Slug: " + slug + "\r\n")
            f.write("authors: " + authors + "\r\n")
            f.write("summary: " + summary + "\r\n")
            if img_adr and image:
                f.write("image: " + img_adr + image + "\r\n\r\n")
                f.write("![" + img_desc + " <>](/images" + img_adr + image + ")\r\n\r\n")
            else:
                f.write("\r\n")
            f.write(article)

        logger.info("Updated post: %s", filepath)
        self.write('Post updated successfully')

        


